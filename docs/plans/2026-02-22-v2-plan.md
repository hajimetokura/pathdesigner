# PathDesigner V2 Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Extend V1 contour-only CAM to support interior contours, rotation, nesting, multi-object SBP, pocket, and drill operations with a unified reactive data flow.

**Architecture:** Incremental extension of the existing React Flow + FastAPI stack. Phase 7 unifies data flow to reactive (useStore) across all nodes and adds a Dam node. Phases 8-11 add features on top of that foundation.

**Tech Stack:** React Flow (useStore), FastAPI, Shapely (collision/nesting), build123d (BREP analysis)

**Design doc:** `docs/plans/2026-02-22-v2-design.md`

---

## Phase 7: データフロー統一 + Damノード

### Task 7.1: OperationNodeをリアクティブ化

**Files:**
- Modify: `frontend/src/nodes/OperationNode.tsx`

**概要:** `getEdges()/getNode()` パターン（ボタン押下時の命令的取得）を `useStore` パターン（リアクティブ購読）に変更。PlacementNodeのパターン（L21-32）を参考にする。

**Step 1: useStoreセレクタを追加**

PlacementNode (L21-32) と同じパターンで、上流の PlacementNode から `placementResult` と `fileId` を購読するセレクタを作成:

```typescript
import { useStore } from "@xyflow/react";

const placementSelector = useMemo(() => (s: ReactFlowState) => {
  const edge = s.edges.find((e) => e.target === id && e.targetHandle === `${id}-brep`);
  if (!edge) return undefined;
  const node = s.nodeLookup.get(edge.source);
  return {
    placementResult: node?.data?.placementResult as { placements: PlacementItem[]; stock: StockSettings; objects: BrepObject[] } | undefined,
    fileId: node?.data?.fileId as string | undefined,
  };
}, [id]);
const upstream = useStore(placementSelector);
```

**Step 2: handleDetect を自動実行に変更**

`handleDetect` から `getEdges()/getNode()` を削除し、`upstream` からデータを取得。`useEffect` で上流データ変更時に自動的に `detectOperations()` を呼ぶ:

```typescript
useEffect(() => {
  if (!upstream?.placementResult || !upstream?.fileId) return;
  const { placements, stock, objects } = upstream.placementResult;
  const objectIds = objects.map((o) => o.object_id);
  // detectOperations API call...
}, [upstream?.placementResult, upstream?.fileId]);
```

**Step 3: "Detect Operations" ボタンを削除**

自動検出になるため不要。ローディング中はスピナー表示。

**Step 4: テスト**

Run: `make dev` でフロントエンド起動。STEPアップロード → Placement設定 → OperationNodeが自動的に操作検出することを確認。

**Step 5: コミット**

```bash
git commit -m "Phase 7: Refactor OperationNode to reactive useStore pattern"
```

---

### Task 7.2: ToolpathGenNodeをリアクティブ化

**Files:**
- Modify: `frontend/src/nodes/ToolpathGenNode.tsx`

**概要:** 現在 `getEdges()/getNode()` で4つの上流ノードをトレースしている複雑なロジック（L26-108）を `useStore` に変更。

**Step 1: useStoreセレクタを追加**

3つの上流入力を購読:
- OperationNode → `detectedOperations`, `assignments`, `stockSettings`, `placements`
- PostProcessorNode → `postProcessorSettings`

```typescript
const operationsSelector = useMemo(() => (s: ReactFlowState) => {
  const edge = s.edges.find((e) => e.target === id && e.targetHandle === `${id}-operations`);
  if (!edge) return undefined;
  const node = s.nodeLookup.get(edge.source);
  return {
    detectedOperations: node?.data?.detectedOperations,
    assignments: node?.data?.assignments,
    stockSettings: node?.data?.stockSettings,
    placements: node?.data?.placements,
  };
}, [id]);

const postProcSelector = useMemo(() => (s: ReactFlowState) => {
  const edge = s.edges.find((e) => e.target === id && e.targetHandle === `${id}-postprocessor`);
  if (!edge) return undefined;
  return s.nodeLookup.get(edge.source)?.data?.postProcessorSettings;
}, [id]);
```

**Step 2: objectOrigins の取得方法を変更**

現在 ToolpathGenNode は PlacementNode まで遡ってトレースしている（L52-70）。OperationNode が `data.placements` に placements 情報を含めているので、そこから取得。`objectOrigins` は OperationNode 側の `data` に追加する（Task 7.1 のデータ出力に含める）。

**Step 3: useEffectで自動生成**

```typescript
useEffect(() => {
  if (!operations?.assignments?.length || !operations?.detectedOperations || !postProc) return;
  // generateToolpath + generateSbp API calls...
}, [operations, postProc]);
```

**Step 4: 下流へのプッシュ書き込みを削除**

現在 ToolpathGenNode は `setNodes` で下流ノード（CncCodeNode, ToolpathPreviewNode）にデータを直接書き込んでいる（L141-158）。これを廃止し、自分の `data` にのみ保存する。下流ノードは Task 7.3 で useStore に変更。

**Step 5: "Generate" ボタンを削除**

自動生成になるため不要。ローディング中はスピナー表示、エラー時は赤枠。

**Step 6: テスト**

STEPアップロード → 設定変更 → ToolpathGenNodeが自動的にツールパスを生成することを確認。

**Step 7: コミット**

```bash
git commit -m "Phase 7: Refactor ToolpathGenNode to reactive useStore pattern"
```

---

### Task 7.3: CncCodeNode/ToolpathPreviewNodeをuseStoreに変更

**Files:**
- Modify: `frontend/src/nodes/CncCodeNode.tsx`
- Modify: `frontend/src/nodes/ToolpathPreviewNode.tsx`

**概要:** 現在は ToolpathGenNode からの `setNodes` プッシュで `data.outputResult` / `data.toolpathResult` を受信している。`useStore` に変更してエッジ経由で上流データを読む。

**Step 1: CncCodeNodeにuseStoreセレクタ追加**

```typescript
const outputSelector = useMemo(() => (s: ReactFlowState) => {
  const edge = s.edges.find((e) => e.target === id && e.targetHandle === `${id}-in`);
  if (!edge) return undefined;
  return s.nodeLookup.get(edge.source)?.data?.outputResult as OutputResult | undefined;
}, [id]);
const outputResult = useStore(outputSelector);
```

`data` propからの直読み（L12）を削除。

**Step 2: ToolpathPreviewNodeも同様に変更**

```typescript
const toolpathSelector = useMemo(() => (s: ReactFlowState) => {
  const edge = s.edges.find((e) => e.target === id && e.targetHandle === `${id}-in`);
  if (!edge) return undefined;
  const node = s.nodeLookup.get(edge.source);
  return {
    toolpathResult: node?.data?.toolpathResult as ToolpathGenResult | undefined,
    stockSettings: node?.data?.stockSettings as StockSettings | undefined,
  };
}, [id]);
```

**Step 3: テスト**

全フロー（STEP → SBP出力）が動作することを確認。CncCodeNodeが自動的にコードを表示、ToolpathPreviewNodeがプレビューを表示。

**Step 4: コミット**

```bash
git commit -m "Phase 7: Refactor CncCodeNode and ToolpathPreviewNode to useStore"
```

---

### Task 7.4: useStoreセレクタのカスタムフック抽出

**Files:**
- Create: `frontend/src/hooks/useUpstreamData.ts`
- Modify: 全ノードファイル（PlacementNode, OperationNode, ToolpathGenNode, CncCodeNode, ToolpathPreviewNode）

**概要:** 全ノードで重複している `useStore` + `useMemo` + エッジ検索パターンを共通フックに抽出。

**Step 1: カスタムフック作成**

```typescript
// frontend/src/hooks/useUpstreamData.ts
import { useMemo } from "react";
import { useStore } from "@xyflow/react";

export function useUpstreamData<T>(
  nodeId: string,
  targetHandle: string,
  selector: (data: Record<string, unknown>) => T
): T | undefined {
  const memoSelector = useMemo(
    () => (s: { edges: Array<{ target: string; targetHandle?: string; source: string }>; nodeLookup: Map<string, { data?: Record<string, unknown> }> }) => {
      const edge = s.edges.find(
        (e) => e.target === nodeId && e.targetHandle === targetHandle
      );
      if (!edge) return undefined;
      const node = s.nodeLookup.get(edge.source);
      if (!node?.data) return undefined;
      return selector(node.data);
    },
    [nodeId, targetHandle]
  );
  return useStore(memoSelector);
}
```

**Step 2: 各ノードをリファクタリング**

例 — PlacementNode:
```typescript
const brepResult = useUpstreamData<BrepImportResult>(
  id, `${id}-brep`,
  (data) => data.brepResult as BrepImportResult
);
```

**Step 3: テスト**

全フローが動作することを確認。

**Step 4: コミット**

```bash
git commit -m "Phase 7: Extract useUpstreamData custom hook for DRY data flow"
```

---

### Task 7.5: Damノード実装

**Files:**
- Create: `frontend/src/nodes/DamNode.tsx`
- Modify: `frontend/src/Sidebar.tsx` (ノードパレットに追加)
- Modify: `frontend/src/App.tsx` (nodeTypes登録)

**Step 1: DamNode コンポーネント作成**

```typescript
// frontend/src/nodes/DamNode.tsx
// - 入力ハンドル1つ (${id}-in)、出力ハンドル1つ (${id}-out)
// - useUpstreamData で上流データを購読
// - state: heldData (上流からの最新データ), releasedData (下流に公開中のデータ)
// - "Release" ボタン: heldData → releasedData にコピー → setNodes で data.damOutput に保存
// - heldData !== releasedData のとき黄色バッジ表示
```

主要ロジック:
```typescript
const upstreamData = useUpstreamData(id, `${id}-in`, (data) => data);
const [releasedData, setReleasedData] = useState<unknown>(undefined);
const hasUpdate = upstreamData !== releasedData;

const handleRelease = () => {
  setReleasedData(upstreamData);
  setNodes((nds) => nds.map((n) =>
    n.id === id ? { ...n, data: { ...n.data, ...upstreamData } } : n
  ));
};
```

**Step 2: Sidebarにエントリ追加**

```typescript
{ type: "dam", label: "Dam", color: "#ffc107" }
```

**Step 3: App.tsxにnodeType登録**

```typescript
const nodeTypes = useMemo(() => ({
  ...existingTypes,
  dam: DamNode,
}), []);
```

**Step 4: テスト**

DamノードをBrepImport → Placement間にドロップ。STEPアップロード後、Damが黄色バッジを表示。Releaseボタンで下流に伝播することを確認。

**Step 5: コミット**

```bash
git commit -m "Phase 7: Add DamNode for flow control"
```

---

### Task 7.6: ローディング/エラー状態表示

**Files:**
- Modify: `frontend/src/nodes/OperationNode.tsx`
- Modify: `frontend/src/nodes/ToolpathGenNode.tsx`

**概要:** 自動実行されるAPIコールにローディングスピナーとエラー表示を追加。

**Step 1: 共通パターン**

```typescript
const [loading, setLoading] = useState(false);
const [error, setError] = useState<string | null>(null);

// useEffect内:
setLoading(true);
setError(null);
try {
  // API call...
} catch (e) {
  setError(e instanceof Error ? e.message : "Unknown error");
} finally {
  setLoading(false);
}
```

**Step 2: UI表示**

- loading中: ノード内にスピナー（CSS animation）
- error時: ノードのborderを赤に、エラーメッセージを表示

**Step 3: コミット**

```bash
git commit -m "Phase 7: Add loading spinner and error display for reactive nodes"
```

---

## Phase 8: Interior Contour + 回転配置 + 衝突判定

### Task 8.1: contour_extract.pyでinterior/exterior分類

**Files:**
- Modify: `backend/nodes/contour_extract.py`
- Modify: `backend/tests/test_contour_extract.py`

**概要:** 現在、全contourが `type="exterior"` にハードコードされている（L64）。Face の `outer_wire()` / `inner_wires()` を活用して正しく分類する。

**Step 1: テスト作成**

```python
# test_contour_extract.py に追加
def test_interior_contours_detected(simple_box_with_hole_step):
    """穴のあるボックスでinterior contourが検出される"""
    result = extract_contours(simple_box_with_hole_step, "obj_001")
    types = [c.type for c in result.contours]
    assert "exterior" in types
    assert "interior" in types

def test_small_holes_filtered_by_tool_diameter(simple_box_with_small_hole_step):
    """刃物径より小さい穴はフィルタリングされる"""
    result = extract_contours(
        simple_box_with_small_hole_step, "obj_001", tool_diameter=6.35
    )
    types = [c.type for c in result.contours]
    assert "interior" not in types  # 小さい穴は除外
```

Run: `cd backend && uv run python -m pytest tests/test_contour_extract.py -v`
Expected: FAIL

**Step 2: フィクスチャ作成**

```python
# conftest.py に追加
@pytest.fixture
def simple_box_with_hole_step(tmp_path):
    from build123d import Box, Cylinder, Pos
    box = Box(100, 50, 10)
    hole = Pos(30, 0, 0) * Cylinder(10, 10)  # 直径20mm穴
    result = box - hole
    path = tmp_path / "box_with_hole.step"
    result.export_step(str(path))
    return str(path)

@pytest.fixture
def simple_box_with_small_hole_step(tmp_path):
    from build123d import Box, Cylinder, Pos
    box = Box(100, 50, 10)
    hole = Pos(30, 0, 0) * Cylinder(2, 10)  # 直径4mm穴（< 6.35mm刃物径）
    result = box - hole
    path = tmp_path / "box_with_small_hole.step"
    result.export_step(str(path))
    return str(path)
```

**Step 3: _intersect_wires を修正**

`_intersect_wires()` (L94-114) は現在 `outer_wire()` と `inner_wires()` を同じリストに入れている。ワイヤを `(wire, type)` タプルで返すように変更:

```python
def _intersect_wires(solid, plane):
    """Returns list of (wire, contour_type) tuples."""
    result = solid.intersect(plane)
    wires = []
    if result is None:
        return wires
    items = result if isinstance(result, ShapeList) else [result]
    for item in items:
        if hasattr(item, "outer_wire"):  # Face
            wires.append((item.outer_wire(), "exterior"))
            for iw in item.inner_wires():
                wires.append((iw, "interior"))
        else:  # Wire
            wires.append((item, "exterior"))
    return wires
```

**Step 4: extract_contours を修正**

ワイヤのtype情報を contour まで伝播。刃物径フィルタを追加:

```python
min_hole_area = math.pi * (tool_diameter / 2) ** 2

for wire, contour_type in typed_wires:
    polygon = _wire_to_polygon(wire)
    if polygon is None or polygon.is_empty:
        continue
    # 刃物径フィルタ: interiorで面積が小さすぎる穴を除外
    if contour_type == "interior" and polygon.area < min_hole_area:
        continue
    # オフセット方向: exteriorはoutside, interiorはinside
    if contour_type == "exterior":
        offset_polygon = _apply_offset(polygon, offset_distance, "outside")
    else:
        offset_polygon = _apply_offset(polygon, offset_distance, "inside")
    contours.append(Contour(
        id=f"contour_{len(contours)+1:03d}",
        type=contour_type,
        coords=_polygon_to_coords(offset_polygon),
        closed=True,
    ))
```

**Step 5: テスト実行**

Run: `cd backend && uv run python -m pytest tests/test_contour_extract.py -v`
Expected: PASS

**Step 6: コミット**

```bash
git commit -m "Phase 8: Detect interior contours and filter by tool diameter"
```

---

### Task 8.2: toolpath_gen.pyでinterior contour処理

**Files:**
- Modify: `backend/nodes/toolpath_gen.py`
- Modify: `backend/tests/test_toolpath_gen.py`

**概要:** `if contour.type != "exterior": continue` (L104-106) を削除し、interior contourのツールパスを生成。

**Step 1: テスト作成**

```python
def test_interior_contours_processed():
    """interior contourもツールパスに含まれる"""
    # DetectedOperation に interior contour を含むテストデータ作成
    # generate_toolpath_from_operations() を呼び、結果に interior contour のパスが含まれることを確認
```

**Step 2: スキップ条件を削除**

`toolpath_gen.py` L104-106 の `if contour.type != "exterior": continue` を削除。

**Step 3: 加工順序の実装**

各オブジェクト内で interior → exterior の順にソート:

```python
sorted_contours = sorted(
    detected_op.geometry.contours,
    key=lambda c: (0 if c.type == "interior" else 1)
)
for contour in sorted_contours:
    # ... generate toolpath
```

**Step 4: テスト実行・コミット**

```bash
git commit -m "Phase 8: Generate toolpaths for interior contours"
```

---

### Task 8.3: 回転配置 — バックエンド

**Files:**
- Modify: `backend/schemas.py` (PlacementItem.rotation バリデーション)
- Modify: `backend/nodes/toolpath_gen.py` (回転座標変換)
- Modify: `backend/nodes/contour_extract.py` (回転適用)
- Create: `backend/nodes/geometry_utils.py` (Shapely回転ユーティリティ)
- Modify: `backend/tests/test_toolpath_gen.py`

**Step 1: 共通ユーティリティ作成**

`_intersect_wires` と `_sample_wire_coords` が `brep_import.py` と `contour_extract.py` で重複している。共通モジュールに抽出し、回転ユーティリティも追加:

```python
# backend/nodes/geometry_utils.py
from shapely.affinity import rotate as shapely_rotate
from shapely.geometry import Polygon

def rotate_polygon(polygon: Polygon, angle: float, origin: tuple[float, float]) -> Polygon:
    """Rotate polygon by angle (degrees) around origin."""
    if angle == 0:
        return polygon
    return shapely_rotate(polygon, angle, origin=origin, use_radians=False)

def rotate_coords(coords: list[list[float]], angle: float, cx: float, cy: float) -> list[list[float]]:
    """Rotate 2D coordinate list by angle (degrees) around (cx, cy)."""
    if angle == 0:
        return coords
    poly = Polygon(coords)
    rotated = shapely_rotate(poly, angle, origin=(cx, cy), use_radians=False)
    return [list(c) for c in rotated.exterior.coords]
```

**Step 2: PlacementItem.rotation バリデーション**

`schemas.py` の `PlacementItem` (L263-267) に Pydantic validator を追加:

```python
from pydantic import field_validator

class PlacementItem(BaseModel):
    object_id: str
    material_id: str = "mat_001"
    x_offset: float = 0
    y_offset: float = 0
    rotation: int = 0

    @field_validator("rotation")
    @classmethod
    def validate_rotation(cls, v):
        if v % 45 != 0 or v < 0 or v >= 360:
            raise ValueError("rotation must be 0, 45, 90, 135, 180, 225, 270, or 315")
        return v
```

**Step 3: toolpath_gen.py で回転座標変換**

`generate_toolpath_from_operations()` の座標変換ロジック（L88-96）に回転を追加:

```python
from nodes.geometry_utils import rotate_coords

# 既存: offset_coords = [[c[0] + dx, c[1] + dy] for c in contour.coords]
# 変更: 回転後にオフセット
placement = plc_lookup.get(detected_op.object_id)
rotation = placement.rotation if placement else 0

if rotation != 0:
    # BB中心を回転原点として使用
    bb = ...  # bounding_box from detected_op or upstream
    cx, cy = bb.x / 2, bb.y / 2
    rotated = rotate_coords(contour.coords, rotation, cx, cy)
    offset_coords = [[c[0] + dx, c[1] + dy] for c in rotated]
else:
    offset_coords = [[c[0] + dx, c[1] + dy] for c in contour.coords]
```

**Step 4: テスト・コミット**

```bash
git commit -m "Phase 8: Add rotation support to backend coordinate transforms"
```

---

### Task 8.4: 回転配置 — フロントエンド

**Files:**
- Modify: `frontend/src/components/PlacementPanel.tsx`
- Modify: `frontend/src/nodes/PlacementNode.tsx`

**Step 1: PlacementPanel に回転ボタン追加**

各パーツのオフセット入力の横に回転ボタンを追加:

```typescript
<button onClick={() => {
  const newPlacements = placements.map((p) =>
    p.object_id === objId
      ? { ...p, rotation: ((p.rotation || 0) + 45) % 360 }
      : p
  );
  onPlacementsChange(newPlacements);
}}>
  ⟳ {placement.rotation || 0}°
</button>
```

**Step 2: Canvas描画に回転を適用**

PlacementPanel のCanvas描画（L94-118）でアウトラインを回転:

```typescript
ctx.save();
// パーツ中心に移動
const cx = placement.x_offset + bb.x / 2;
const cy = placement.y_offset + bb.y / 2;
ctx.translate(cx * scale + padding, canvasH - (cy * scale + padding));
ctx.rotate((-placement.rotation * Math.PI) / 180);
ctx.translate(-(cx * scale + padding), -(canvasH - (cy * scale + padding)));
// アウトライン描画...
ctx.restore();
```

**Step 3: テスト・コミット**

```bash
git commit -m "Phase 8: Add 45-degree rotation UI to PlacementPanel"
```

---

### Task 8.5: 輪郭ベース衝突判定

**Files:**
- Modify: `backend/main.py` (`/api/validate-placement` 拡張)
- Modify: `backend/schemas.py` (BrepObject.outline を活用)
- Create: `backend/tests/test_collision.py`

**Step 1: テスト作成**

```python
def test_overlapping_placements_detected():
    """重なる配置が検出される"""
    # 2つのオブジェクトを同じ位置に配置
    # validate_placement が valid=False, warnings に衝突メッセージ

def test_non_overlapping_placements_valid():
    """離れた配置は衝突なし"""

def test_tool_diameter_margin_applied():
    """ツール径マージンが考慮される"""
```

**Step 2: validate-placement エンドポイント拡張**

現在は BB ベースのみ（`main.py` L222-243）。輪郭ベースの衝突判定を追加:

```python
# main.py の validate-placement エンドポイント
from shapely.geometry import Polygon
from nodes.geometry_utils import rotate_polygon

@app.post("/api/validate-placement")
async def validate_placement_endpoint(req: ValidatePlacementRequest):
    warnings = []
    # ... 既存のBB範囲チェック ...

    # 輪郭ベース衝突判定
    polygons = {}
    for p in req.placements:
        outline = req.outlines.get(p.object_id, [])
        if len(outline) < 3:
            # フォールバック: BB矩形
            bb = req.bounding_boxes[p.object_id]
            outline = [[0,0], [bb.x,0], [bb.x,bb.y], [0,bb.y]]
        poly = Polygon(outline)
        # 回転適用
        if p.rotation:
            cx, cy = poly.centroid.x, poly.centroid.y
            poly = rotate_polygon(poly, p.rotation, (cx, cy))
        # ツール径マージン
        poly = poly.buffer(req.tool_diameter / 2)
        # 配置オフセット適用
        from shapely.affinity import translate
        poly = translate(poly, p.x_offset, p.y_offset)
        polygons[p.object_id] = poly

    # 全ペアの衝突チェック
    ids = list(polygons.keys())
    for i in range(len(ids)):
        for j in range(i + 1, len(ids)):
            if polygons[ids[i]].intersects(polygons[ids[j]]):
                warnings.append(f"Collision: {ids[i]} and {ids[j]}")

    valid = len(warnings) == 0
    return ValidatePlacementResponse(valid=valid, warnings=warnings)
```

**Step 3: ValidatePlacementRequest スキーマ拡張**

```python
class ValidatePlacementRequest(BaseModel):
    placements: list[PlacementItem]
    stock: StockSettings
    bounding_boxes: dict[str, BoundingBox]
    outlines: dict[str, list[list[float]]] = {}  # 追加
    tool_diameter: float = 6.35  # 追加
```

**Step 4: フロントエンドで衝突表示**

PlacementNode / PlacementPanel で `validatePlacement` API のレスポンスに応じて赤枠表示。`api.ts` の `validatePlacement` に `outlines` パラメータを追加。

**Step 5: テスト実行・コミット**

```bash
git commit -m "Phase 8: Outline-based collision detection with tool diameter margin"
```

---

## Phase 9: 複数オブジェクトSBP生成

### Task 9.1: SbpWriter を複数オペレーション対応に

**Files:**
- Modify: `backend/sbp_writer.py`
- Modify: `backend/tests/test_sbp_writer.py`

**概要:** 現在の `SbpWriter` は1つの `MachiningSettings` のみ受け取る。オペレーションごとに異なる設定をサポートする。

**Step 1: テスト作成**

```python
def test_multi_operation_sbp():
    """複数オペレーション（異なる設定）のSBP生成"""
    # 2つのオペレーション、異なるfeed_rate
    # 生成されたSBPにMS行が2回出現することを確認

def test_same_settings_skip_reconfig():
    """同一設定の連続オペレーションで再設定をスキップ"""

def test_object_sort_by_placement():
    """配置位置で左下→右上にソートされる"""
```

**Step 2: SbpWriter リファクタリング**

```python
class SbpWriter:
    def __init__(self, settings: PostProcessorSettings, stock: StockSettings | None = None):
        # machining を外す（オペレーションごとに変わる）
        self.settings = settings
        self.stock = stock

    def generate(self, toolpaths: list[Toolpath], operations: list[OperationAssignment]) -> str:
        # operations を配置位置でソート（y昇順 → x昇順）
        # ヘッダ出力
        # 各オペレーションごとに:
        #   - 前回と設定が異なる場合のみ tool_spindle + speed_settings を出力
        #   - cutting_passes
        #   - オブジェクト間 Safe Z 退避 + Jog移動
        # フッタ出力
```

**Step 3: main.py の generate-sbp エンドポイント修正**

`req.operations[0].settings` のハードコードを削除。全オペレーションの設定をSbpWriterに渡す。

**Step 4: テスト・コミット**

```bash
git commit -m "Phase 9: Multi-operation SBP generation with per-object settings"
```

---

### Task 9.2: 加工順序ソート実装

**Files:**
- Modify: `backend/sbp_writer.py`
- Modify: `backend/nodes/toolpath_gen.py`

**概要:** オブジェクトを配置位置で左下→右上にソート。オブジェクト内は drill → pocket → interior → exterior の順。

**Step 1: ソートロジック**

```python
def _sort_operations(operations, placements):
    """配置位置で左下→右上にソート"""
    plc_map = {p.object_id: p for p in placements}
    return sorted(operations, key=lambda op: (
        plc_map.get(op.object_id, PlacementItem()).y_offset,
        plc_map.get(op.object_id, PlacementItem()).x_offset,
    ))
```

**Step 2: オブジェクト内順序**

```python
OPERATION_ORDER = {"drill": 0, "pocket": 1, "interior_contour": 2, "exterior_contour": 3}
```

interior/exterior contour はcontour typeで区別（Phase 8で追加済み）。

**Step 3: テスト・コミット**

```bash
git commit -m "Phase 9: Sort operations by placement position and type"
```

---

## Phase 10: ネスティング（Auto Nesting）

### Task 10.1: BLFアルゴリズム実装

**Files:**
- Create: `backend/nodes/nesting.py`
- Create: `backend/tests/test_nesting.py`

**Step 1: テスト作成**

```python
def test_single_part_bottom_left():
    """1パーツは左下に配置される"""

def test_two_parts_no_overlap():
    """2パーツが重ならない"""

def test_rotation_tried():
    """8方向の回転が試される"""

def test_part_exceeds_stock():
    """収まらないパーツに警告"""
```

**Step 2: BLFアルゴリズム実装**

```python
# backend/nodes/nesting.py
from shapely.geometry import Polygon, box
from shapely.affinity import translate, rotate
from schemas import PlacementItem, StockSettings, BrepObject

def auto_nesting(
    objects: list[BrepObject],
    stock: StockSettings,
    tool_diameter: float = 6.35,
    clearance: float = 5.0,
) -> list[PlacementItem]:
    """Bottom-Left Fill nesting algorithm."""
    margin = tool_diameter / 2 + clearance
    stock_mat = stock.materials[0]
    stock_poly = box(0, 0, stock_mat.width, stock_mat.depth)

    # 面積降順でソート
    sorted_objects = sorted(objects, key=lambda o: o.bounding_box.x * o.bounding_box.y, reverse=True)

    placed_polygons: list[Polygon] = []
    placements: list[PlacementItem] = []

    for obj in sorted_objects:
        outline = obj.outline if len(obj.outline) >= 3 else _bb_outline(obj.bounding_box)
        base_poly = Polygon(outline).buffer(margin)

        best_placement = None
        best_score = float("inf")  # (y, x) — 左下優先

        for angle in range(0, 360, 45):
            rotated = rotate(base_poly, angle, origin="centroid") if angle else base_poly
            # グリッドサーチ (ステップ: 5mm)
            for y in range(0, int(stock_mat.depth), 5):
                for x in range(0, int(stock_mat.width), 5):
                    candidate = translate(rotated, x, y)
                    if not stock_poly.contains(candidate):
                        continue
                    if any(candidate.intersects(p) for p in placed_polygons):
                        continue
                    score = (y, x)
                    if score < best_score:
                        best_score = score
                        best_placement = PlacementItem(
                            object_id=obj.object_id,
                            material_id=stock_mat.material_id,
                            x_offset=x, y_offset=y, rotation=angle,
                        )
                        break  # この y で見つかったら次の y は不要
                if best_placement and best_score == (y, best_placement.x_offset):
                    break
            if best_placement:
                break

        if best_placement:
            placed_poly = translate(
                rotate(base_poly, best_placement.rotation, origin="centroid") if best_placement.rotation else base_poly,
                best_placement.x_offset, best_placement.y_offset,
            )
            placed_polygons.append(placed_poly)
            placements.append(best_placement)
        else:
            # 配置不能 — デフォルト位置で警告付き
            placements.append(PlacementItem(
                object_id=obj.object_id,
                material_id=stock_mat.material_id,
                x_offset=0, y_offset=0, rotation=0,
            ))

    return placements
```

注意: グリッドサーチのステップサイズはパフォーマンスと精度のトレードオフ。5mmは最初の実装として妥当。パフォーマンス問題が出たらNFPに置き換え。

**Step 3: テスト実行・コミット**

```bash
git commit -m "Phase 10: Implement BLF nesting algorithm"
```

---

### Task 10.2: Auto Nesting APIエンドポイント

**Files:**
- Modify: `backend/main.py`
- Modify: `backend/schemas.py`

**Step 1: スキーマ追加**

```python
class AutoNestingRequest(BaseModel):
    objects: list[BrepObject]
    stock: StockSettings
    tool_diameter: float = 6.35
    clearance: float = 5.0

class AutoNestingResponse(BaseModel):
    placements: list[PlacementItem]
    warnings: list[str] = []
```

**Step 2: エンドポイント追加**

```python
@app.post("/api/auto-nesting")
async def auto_nesting_endpoint(req: AutoNestingRequest):
    from nodes.nesting import auto_nesting
    placements = auto_nesting(req.objects, req.stock, req.tool_diameter, req.clearance)
    warnings = []
    # 配置不能チェック
    for p in placements:
        if p.x_offset == 0 and p.y_offset == 0 and p.rotation == 0:
            warnings.append(f"{p.object_id} could not be placed optimally")
    return AutoNestingResponse(placements=placements, warnings=warnings)
```

**Step 3: api.ts に関数追加**

```typescript
export async function autoNesting(
  objects: BrepObject[], stock: StockSettings,
  toolDiameter: number = 6.35, clearance: number = 5.0,
): Promise<{ placements: PlacementItem[]; warnings: string[] }> {
  const res = await fetch(`${API_URL}/api/auto-nesting`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ objects, stock, tool_diameter: toolDiameter, clearance }),
  });
  return res.json();
}
```

**Step 4: コミット**

```bash
git commit -m "Phase 10: Add /api/auto-nesting endpoint"
```

---

### Task 10.3: PlacementPanelにAuto Nestingボタン追加

**Files:**
- Modify: `frontend/src/components/PlacementPanel.tsx`

**Step 1: ボタン追加**

```typescript
const handleAutoNesting = async () => {
  const result = await autoNesting(objects, stockSettings);
  onPlacementsChange(result.placements);
  if (result.warnings.length > 0) {
    // 警告表示
  }
};

// UI
<button onClick={handleAutoNesting}>Auto Nesting</button>
```

**Step 2: クリアランス設定UI**

Auto Nestingボタンの横にクリアランス入力（デフォルト5mm）。

**Step 3: テスト・コミット**

```bash
git commit -m "Phase 10: Add Auto Nesting button to PlacementPanel"
```

---

### Task 10.4: スナップガイド

**Files:**
- Modify: `frontend/src/components/PlacementPanel.tsx`

**概要:** ドラッグ中にスナップガイドライン（材料端、他パーツとのアラインメント）を表示。

**Step 1: スナップ判定ロジック**

```typescript
const SNAP_THRESHOLD = 5; // mm
const snapLines = useMemo(() => {
  const lines: { x?: number; y?: number }[] = [];
  // 材料端
  lines.push({ x: 0 }, { x: stockWidth }, { y: 0 }, { y: stockDepth });
  // 他パーツの端
  for (const p of placements) {
    if (p.object_id === draggingId) continue;
    const bb = objects.find(o => o.object_id === p.object_id)?.bounding_box;
    if (!bb) continue;
    lines.push({ x: p.x_offset }, { x: p.x_offset + bb.x });
    lines.push({ y: p.y_offset }, { y: p.y_offset + bb.y });
  }
  return lines;
}, [placements, objects, draggingId]);
```

**Step 2: Canvas描画**

スナップが近い（< SNAP_THRESHOLD）とき、点線ガイドラインを描画。

**Step 3: コミット**

```bash
git commit -m "Phase 10: Add snap guides for manual placement"
```

---

## Phase 11: ポケット加工 + ドリル加工

### Task 11.1: 操作タイプ自動検出の拡張

**Files:**
- Modify: `backend/nodes/operation_detector.py`
- Modify: `backend/nodes/brep_import.py` (フィーチャー解析拡張)
- Create: `backend/tests/test_feature_detection.py`

**概要:** `detect_operations()` を拡張し、contour以外にpocket/drillを検出。

**Step 1: テスト作成**

```python
def test_through_hole_detected_as_drill(box_with_small_hole_step):
    """貫通 + 円形 + 小径 → drill"""

def test_through_large_hole_detected_as_contour(box_with_large_hole_step):
    """貫通 + 大径 → interior contour"""

def test_blind_pocket_detected(box_with_pocket_step):
    """非貫通くぼみ → pocket"""
```

**Step 2: brep_import.py にフィーチャー解析追加**

build123d の面解析で、各フィーチャーの特性を抽出:

```python
def _analyze_features(solid, bb):
    """ソリッドのフィーチャー（穴・ポケット）を解析"""
    features = []
    # 円筒面を検出（穴の候補）
    cylindrical_faces = [f for f in solid.faces() if f.geom_type() == GeomType.CYLINDER]
    for face in cylindrical_faces:
        # 半径と深さを取得
        radius = face.radius
        depth = _feature_depth(face, bb)
        is_through = abs(depth - bb.size.Z) < 0.1
        features.append({
            "type": "cylindrical",
            "radius": radius,
            "depth": depth,
            "is_through": is_through,
            "center": [face.center().X, face.center().Y],
        })
    # 非貫通面を検出（ポケット候補）
    # ... bottom_features / top_features の面解析から
    return features
```

**Step 3: 判定ロジック実装**

```python
def _classify_operation(feature, tool_diameter):
    if feature["is_through"] and feature["type"] == "cylindrical":
        if feature["radius"] * 2 <= tool_diameter * 2:  # drill径基準
            return "drill"
        return "contour"  # interior contour
    if not feature["is_through"]:
        return "pocket"
    return "contour"
```

**Step 4: テスト実行・コミット**

```bash
git commit -m "Phase 11: Extend operation detection for drill and pocket"
```

---

### Task 11.2: ポケット加工ツールパス（Contour-parallel）

**Files:**
- Create: `backend/nodes/pocket_toolpath.py`
- Create: `backend/tests/test_pocket_toolpath.py`

**Step 1: テスト作成**

```python
def test_contour_parallel_pocket():
    """矩形ポケットのcontour-parallelツールパス"""
    polygon = Polygon([(0,0), (50,0), (50,30), (0,30)])
    paths = generate_pocket_contour_parallel(polygon, tool_diameter=6.35, stepover=0.5)
    assert len(paths) > 1  # 複数のオフセットリング
    # 最内リングの面積 < ツール径の2乗 → これ以上縮小不可

def test_raster_pocket():
    """矩形ポケットのラスターツールパス"""
    polygon = Polygon([(0,0), (50,0), (50,30), (0,30)])
    paths = generate_pocket_raster(polygon, tool_diameter=6.35, stepover=0.5)
    # ジグザグパターンの検証
```

**Step 2: Contour-parallel 実装**

```python
# backend/nodes/pocket_toolpath.py
from shapely.geometry import Polygon
from shapely.ops import unary_union

def generate_pocket_contour_parallel(
    polygon: Polygon, tool_diameter: float, stepover: float = 0.5,
) -> list[list[list[float]]]:
    """Contour-parallel (offset spiral) pocket toolpath."""
    step = tool_diameter * stepover
    paths = []
    current = polygon.buffer(-tool_diameter / 2)  # 初回: ツール半径分内側

    while not current.is_empty and current.area > 0:
        if current.geom_type == "Polygon":
            coords = [list(c) for c in current.exterior.coords]
            paths.append(coords)
        elif current.geom_type == "MultiPolygon":
            for poly in current.geoms:
                coords = [list(c) for c in poly.exterior.coords]
                paths.append(coords)
        current = current.buffer(-step)

    return paths
```

**Step 3: Raster 実装**

```python
def generate_pocket_raster(
    polygon: Polygon, tool_diameter: float, stepover: float = 0.5,
) -> list[list[list[float]]]:
    """Raster (zigzag) pocket toolpath."""
    step = tool_diameter * stepover
    minx, miny, maxx, maxy = polygon.bounds
    inset = polygon.buffer(-tool_diameter / 2)
    if inset.is_empty:
        return []

    paths = []
    y = miny + tool_diameter / 2
    direction = 1  # 1=left-to-right, -1=right-to-left
    while y <= maxy - tool_diameter / 2:
        # Y=y での水平線とポリゴンの交差
        from shapely.geometry import LineString
        scan_line = LineString([(minx - 1, y), (maxx + 1, y)])
        intersection = inset.intersection(scan_line)
        if not intersection.is_empty:
            if intersection.geom_type == "LineString":
                coords = list(intersection.coords)
                if direction == -1:
                    coords.reverse()
                paths.append([[c[0], c[1]] for c in coords])
            elif intersection.geom_type == "MultiLineString":
                segments = list(intersection.geoms)
                if direction == -1:
                    segments.reverse()
                for seg in segments:
                    coords = list(seg.coords)
                    if direction == -1:
                        coords.reverse()
                    paths.append([[c[0], c[1]] for c in coords])
        direction *= -1
        y += step

    return paths
```

**Step 4: テスト実行・コミット**

```bash
git commit -m "Phase 11: Implement pocket toolpath generation (contour-parallel + raster)"
```

---

### Task 11.3: ドリル加工ツールパス（ペックドリル）

**Files:**
- Modify: `backend/nodes/toolpath_gen.py`
- Create: `backend/tests/test_drill_toolpath.py`

**Step 1: テスト作成**

```python
def test_peck_drill_cycle():
    """ペックドリルで正しいZ深さが生成される"""
    # 18mm深さ、6mm/peck → 3ペック
    passes = generate_drill_toolpath(
        center=[25.0, 15.0], total_depth=18.0, depth_per_peck=6.0, safe_z=38.0,
    )
    assert len(passes) == 3
    assert passes[0].z_depth == -6.0
    assert passes[1].z_depth == -12.0
    assert passes[2].z_depth == -18.3  # penetration margin
```

**Step 2: 実装**

```python
def generate_drill_toolpath(
    center: list[float], total_depth: float,
    depth_per_peck: float = 6.0, safe_z: float = 38.0,
) -> list[ToolpathPass]:
    """Peck drill cycle: drill to depth, retract, repeat."""
    num_pecks = math.ceil(total_depth / depth_per_peck)
    passes = []
    for i in range(num_pecks):
        is_final = i == num_pecks - 1
        if is_final:
            z_depth = -(total_depth + PENETRATION_MARGIN)
        else:
            z_depth = -((i + 1) * depth_per_peck)
        passes.append(ToolpathPass(
            pass_number=i + 1,
            z_depth=z_depth,
            path=[center, center],  # ドリルは同一座標
            tabs=[],
        ))
    return passes
```

**Step 3: SBP出力でのドリルコマンド**

`sbp_writer.py` でドリル操作を検出し、`MZ` コマンドを使用:

```python
if operation_type == "drill":
    self.lines.append(f"MZ,{z_depth:.3f}")  # Z軸のみ移動
    self.lines.append(f"JZ,{self.settings.safe_z:.3f}")  # 退避
```

**Step 4: テスト・コミット**

```bash
git commit -m "Phase 11: Implement peck drill toolpath and SBP output"
```

---

### Task 11.4: OperationDetailPanel UIの拡張

**Files:**
- Modify: `frontend/src/components/OperationDetailPanel.tsx`
- Modify: `frontend/src/types.ts`

**概要:** pocket/drill操作タイプに対応するUI要素を追加。

**Step 1: 操作タイプ別設定フィールド**

```typescript
// contour: 既存フィールド + direction, offset_side, tabs
// pocket: stepover (%), strategy (contour-parallel / raster)
// drill: depth_per_peck
```

**Step 2: MachiningSettings型に追加**

```typescript
// types.ts
interface MachiningSettings {
  // 既存フィールド...
  pocket_strategy?: "contour-parallel" | "raster";
  stepover?: number;  // 0-1 (ツール径に対する割合)
  depth_per_peck?: number;  // mm
}
```

**Step 3: OperationDetailPanel で操作タイプに応じた表示**

```typescript
{settings.operation_type === "pocket" && (
  <>
    <label>Strategy</label>
    <select value={settings.pocket_strategy || "contour-parallel"} onChange={...}>
      <option value="contour-parallel">Contour Parallel</option>
      <option value="raster">Raster (Zigzag)</option>
    </select>
    <label>Stepover (%)</label>
    <input type="number" value={(settings.stepover || 0.5) * 100} ... />
  </>
)}
{settings.operation_type === "drill" && (
  <>
    <label>Depth per Peck (mm)</label>
    <input type="number" value={settings.depth_per_peck || 6} ... />
  </>
)}
```

**Step 4: コミット**

```bash
git commit -m "Phase 11: Extend OperationDetailPanel for pocket and drill settings"
```

---

### Task 11.5: バックエンドスキーマ・API統合

**Files:**
- Modify: `backend/schemas.py`
- Modify: `backend/nodes/toolpath_gen.py`
- Modify: `backend/main.py`

**概要:** pocket/drill の新フィールドをスキーマに追加し、`generate_toolpath_from_operations()` を拡張。

**Step 1: MachiningSettings スキーマ拡張**

```python
class MachiningSettings(BaseModel):
    # 既存フィールド...
    pocket_strategy: str = "contour-parallel"  # "contour-parallel" | "raster"
    stepover: float = 0.5  # 0-1
    depth_per_peck: float = 6.0  # mm (drill)
```

**Step 2: generate_toolpath_from_operations() 拡張**

```python
for assignment in sorted_assignments:
    op_type = assignment.settings.operation_type
    if op_type == "contour":
        # 既存ロジック（interior/exterior含む）
    elif op_type == "pocket":
        from nodes.pocket_toolpath import generate_pocket_contour_parallel, generate_pocket_raster
        polygon = Polygon(detected_op.geometry.contours[0].coords)
        if assignment.settings.pocket_strategy == "raster":
            pocket_paths = generate_pocket_raster(polygon, tool_dia, assignment.settings.stepover)
        else:
            pocket_paths = generate_pocket_contour_parallel(polygon, tool_dia, assignment.settings.stepover)
        # pocket_paths をToolpathPassに変換（Z段送り含む）
    elif op_type == "drill":
        center = detected_op.geometry.contours[0].coords[0]  # 穴中心
        drill_passes = generate_drill_toolpath(
            center, total_depth, assignment.settings.depth_per_peck, safe_z,
        )
```

**Step 3: テスト・コミット**

```bash
git commit -m "Phase 11: Integrate pocket and drill into toolpath generation pipeline"
```

---

## 依存関係まとめ

```
Phase 7 (データフロー統一)
  ├─ Task 7.1: OperationNode リアクティブ化
  ├─ Task 7.2: ToolpathGenNode リアクティブ化 (依存: 7.1)
  ├─ Task 7.3: CncCode/Preview useStore化 (依存: 7.2)
  ├─ Task 7.4: useUpstreamData フック抽出 (依存: 7.1-7.3)
  ├─ Task 7.5: Damノード (依存: 7.4)
  └─ Task 7.6: ローディング/エラー表示 (依存: 7.1-7.2)

Phase 8 (Interior + 回転 + 衝突) — 依存: Phase 7 完了
  ├─ Task 8.1: contour_extract interior分類
  ├─ Task 8.2: toolpath_gen interior処理 (依存: 8.1)
  ├─ Task 8.3: 回転バックエンド (独立)
  ├─ Task 8.4: 回転フロントエンド (依存: 8.3)
  └─ Task 8.5: 衝突判定 (依存: 8.3)

Phase 9 (複数オブジェクトSBP) — 依存: Phase 8 完了
  ├─ Task 9.1: SbpWriter 複数オペレーション
  └─ Task 9.2: 加工順序ソート (依存: 9.1)

Phase 10 (ネスティング) — 依存: Phase 8 完了
  ├─ Task 10.1: BLFアルゴリズム (独立)
  ├─ Task 10.2: API エンドポイント (依存: 10.1)
  ├─ Task 10.3: UI Auto Nesting ボタン (依存: 10.2)
  └─ Task 10.4: スナップガイド (独立)

Phase 11 (ポケット + ドリル) — 依存: Phase 9 完了
  ├─ Task 11.1: 操作タイプ自動検出
  ├─ Task 11.2: ポケットツールパス (独立)
  ├─ Task 11.3: ドリルツールパス (独立)
  ├─ Task 11.4: UI拡張 (依存: 11.1)
  └─ Task 11.5: バックエンド統合 (依存: 11.1-11.3)
```

注意: Phase 9 と Phase 10 は互いに独立なので並行作業可能。
