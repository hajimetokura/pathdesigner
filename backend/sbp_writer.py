"""SBP (ShopBot) code generator — EMARF CAM compatible format."""

from schemas import (
    MachiningSettings,
    PostProcessorSettings,
    Toolpath,
    ToolpathPass,
)


class SbpWriter:
    """Generates OpenSBP code from toolpath data."""

    def __init__(
        self,
        settings: PostProcessorSettings,
        machining: MachiningSettings,
    ):
        self.s = settings
        self.m = machining

    def generate(self, toolpaths: list[Toolpath]) -> str:
        """Generate complete SBP file content."""
        lines: list[str] = []
        lines += self._header()
        lines += self._tool_spindle()
        lines += self._material_metadata()
        lines += self._speed_settings()
        lines += self._initial_position()
        for tp in toolpaths:
            lines += self._cutting_passes(tp)
        lines += self._footer()
        return "\n".join(lines)

    def _header(self) -> list[str]:
        return [
            "'SHOPBOT ROUTER FILE IN MM",
            "'GENERATED BY PathDesigner",
            "IF %(25)=0 THEN GOTO UNIT_ERROR",
            "SA",
            "CN,90",
            "",
        ]

    def _tool_spindle(self) -> list[str]:
        sw = self.s.spindle_warmup
        return [
            f"&Tool = {self.s.tool_number}",
            "C9",
            f"TR,{sw.initial_rpm}",
            "C6",
            f"PAUSE {sw.wait_seconds}",
            "",
        ]

    def _material_metadata(self) -> list[str]:
        mat = self.s.material
        return [
            f"'MATERIAL_WIDTH:{mat.width:g}",
            f"'MATERIAL_DEPTH:{mat.depth:g}",
            f"'MATERIAL_THICKNESS:{mat.thickness:g}",
            f"'MILL_SIZE:{self.m.tool.diameter:g}",
            "",
        ]

    def _speed_settings(self) -> list[str]:
        return [
            f"MS,{self.m.feed_rate.xy},{self.m.feed_rate.z}",
            f"JS,{self.m.jog_speed}",
            "",
        ]

    def _initial_position(self) -> list[str]:
        home = self.s.home_position
        return [
            f"JZ,{self.s.safe_z}",
            f"J2,{home[0]},{home[1]}",
            "",
        ]

    def _cutting_passes(self, toolpath: Toolpath) -> list[str]:
        """Generate cutting commands for all passes in a toolpath."""
        lines: list[str] = []
        passes = toolpath.passes
        if not passes:
            return lines

        first_path = passes[0].path
        if not first_path:
            return lines

        start_x, start_y = first_path[0]

        # Jog to start position
        lines.append(f"J2,{start_x},{start_y}")

        for p in passes:
            lines += self._single_pass(p)

        # Retract after all passes
        lines.append(f"JZ,{self.s.safe_z}")
        lines.append("")

        return lines

    def _single_pass(self, tp_pass: ToolpathPass) -> list[str]:
        """Generate M3 commands for a single cutting pass."""
        lines: list[str] = []
        path = tp_pass.path
        if not path:
            return lines

        # Descend to pass depth at start point
        lines += self._descend(path[0], tp_pass.z_depth)

        # Build index-to-tab-z lookup
        tab_z_map: dict[int, float] = {}
        for tab in tp_pass.tabs:
            for idx in range(tab.start_index, tab.end_index + 1):
                tab_z_map[idx] = tab.z_tab

        # Cut along the contour (skip first point — already there from descend)
        for i in range(1, len(path)):
            x, y = path[i]
            z = tab_z_map.get(i, tp_pass.z_depth)
            lines.append(f"M3,{x},{y},{z}")

        return lines

    def _descend(self, point: list[float], z_depth: float) -> list[str]:
        """Descend to cutting depth at the given point."""
        x, y = point
        return [f"M3,{x},{y},{z_depth}"]

    def _footer(self) -> list[str]:
        home = self.s.home_position
        return [
            f"JZ,{self.s.safe_z}",
            f"J2,{home[0]},{home[1]}",
            "C7",
            "END",
            "",
            "UNIT_ERROR:",
            "CN, 91",
            "END",
        ]
