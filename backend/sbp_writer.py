"""SBP (ShopBot) code generator — EMARF CAM compatible format."""

from schemas import (
    MachiningSettings,
    PostProcessorSettings,
    StockSettings,
    Toolpath,
    ToolpathPass,
)


class SbpWriter:
    """Generates OpenSBP code from toolpath data."""

    def __init__(
        self,
        settings: PostProcessorSettings,
        machining: MachiningSettings,
        stock: StockSettings | None = None,
    ):
        self.s = settings
        self.m = machining
        self.stock = stock

    def generate(self, toolpaths: list[Toolpath]) -> str:
        """Generate complete SBP file content.

        If individual toolpaths carry their own settings, per-toolpath
        tool/speed commands are emitted only when they differ from the
        previous toolpath.
        """
        lines: list[str] = []
        lines += self._header()
        lines += self._tool_spindle()
        lines += self._material_metadata()
        lines += self._speed_settings()
        lines += self._initial_position()

        # Track current active settings to avoid duplicate commands
        active = self.m

        for tp in toolpaths:
            tp_settings = tp.settings or self.m

            # Emit setting changes if different from active
            if tp.settings and tp_settings != active:
                lines += self._settings_change(active, tp_settings)
                active = tp_settings

            lines += self._cutting_passes(tp)

        lines += self._footer()
        return "\n".join(lines)

    def _header(self) -> list[str]:
        return [
            "'SHOPBOT ROUTER FILE IN MM",
            f"'GENERATED BY PathDesigner ({self.s.machine_name})",
            "IF %(25)=0 THEN GOTO UNIT_ERROR",
            "SA",
            "CN,90",
            "'",
        ]

    def _tool_spindle(self) -> list[str]:
        return [
            f"&Tool = {self.s.tool_number}",
            "C9",
            f"TR,{self.m.spindle_speed}",
            "C6",
            f"PAUSE {self.s.warmup_pause}",
            "'",
        ]

    def _material_metadata(self) -> list[str]:
        lines: list[str] = []
        if self.stock:
            for mat in self.stock.materials:
                lines.extend([
                    f"'MATERIAL_ID:{mat.material_id}",
                    f"'MATERIAL_WIDTH:{mat.width:g}",
                    f"'MATERIAL_DEPTH:{mat.depth:g}",
                    f"'MATERIAL_THICKNESS:{mat.thickness:g}",
                ])
        lines.append(f"'MILL_SIZE:{self.m.tool.diameter:g}")
        lines.append("'")
        return lines

    def _speed_settings(self) -> list[str]:
        return [
            f"MS,{self.m.feed_rate.xy},{self.m.feed_rate.z}",
            f"JS,{self.m.jog_speed}",
            "'",
        ]

    def _initial_position(self) -> list[str]:
        home = self.s.home_position
        return [
            f"JZ,{self.s.safe_z}",
            f"J2,{home[0]},{home[1]}",
        ]

    def _settings_change(
        self, prev: MachiningSettings, curr: MachiningSettings
    ) -> list[str]:
        """Emit only the SBP commands needed for changed settings."""
        lines: list[str] = []
        lines.append("'")

        # Spindle speed change
        if curr.spindle_speed != prev.spindle_speed:
            lines.append(f"TR,{curr.spindle_speed}")
            lines.append(f"PAUSE {self.s.warmup_pause}")

        # Feed rate change
        if curr.feed_rate != prev.feed_rate:
            lines.append(f"MS,{curr.feed_rate.xy},{curr.feed_rate.z}")

        # Jog speed change
        if curr.jog_speed != prev.jog_speed:
            lines.append(f"JS,{curr.jog_speed}")

        return lines

    def _cutting_passes(self, toolpath: Toolpath) -> list[str]:
        """Generate cutting commands for all passes in a toolpath."""
        lines: list[str] = []
        passes = toolpath.passes
        if not passes:
            return lines

        first_path = passes[0].path
        if not first_path:
            return lines

        start_x, start_y = first_path[0]

        # Jog to start position
        lines.append(f"J2,{start_x},{start_y}")

        for p in passes:
            lines += self._single_pass(p)

        # Retract after all passes
        lines.append(f"JZ,{self.s.safe_z}")

        return lines

    def _single_pass(self, tp_pass: ToolpathPass) -> list[str]:
        """Generate M3 commands for a single cutting pass."""
        lines: list[str] = []
        path = tp_pass.path
        if not path:
            return lines

        # Descend to pass depth at start point
        lines += self._descend(path[0], tp_pass.z_depth)

        # Build index-to-tab-z lookup
        tab_z_map: dict[int, float] = {}
        for tab in tp_pass.tabs:
            for idx in range(tab.start_index, tab.end_index + 1):
                tab_z_map[idx] = tab.z_tab

        # Cut along the contour (skip first point — already there from descend)
        for i in range(1, len(path)):
            x, y = path[i]
            z = tab_z_map.get(i, tp_pass.z_depth)
            lines.append(f"M3,{x},{y},{z}")

        return lines

    def _descend(self, point: list[float], z_depth: float) -> list[str]:
        """Descend to cutting depth at the given point."""
        x, y = point
        return [f"M3,{x},{y},{z_depth}"]

    def _footer(self) -> list[str]:
        home = self.s.home_position
        return [
            f"JZ,{self.s.safe_z}",
            f"J2,{home[0]},{home[1]}",
            "C7",
            "END",
            "'",
            "UNIT_ERROR:",
            "CN, 91",
            "END",
        ]
